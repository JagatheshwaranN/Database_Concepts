Questions
=========
DDL -> CREATE, ALTER, DROP, TRUNCATE, COMMENT, RENAME, and GRANT
DML -> INSERT, UPDATE, DELETE, and MERGE
TCL -> COMMIT, ROLLBACK, SAVEPOINT, SET TRANSACTION, and AUTOCOMMIT

1. What is DML, and what are its types in Oracle?
DML stands for Data Manipulation Language. It is used to manipulate data in the database. In Oracle, DML
includes commands like INSERT, UPDATE, DELETE, and MERGE.

2. Explain the difference between DDL and DML in Oracle.
1. DDL (Data Definition Language) is used to define and manage the structure of database objects like tables,
indexes, views, etc. Examples of DDL commands include CREATE, ALTER, DROP, TRUNCATE, etc.

2. DML (Data Manipulation Language), on the other hand, is used to manipulate data stored in the database.
Examples of DML commands include INSERT, UPDATE, DELETE, MERGE, etc.

3. What is TCL, and what are its types in Oracle?
TCL stands for Transaction Control Language. It is a category of SQL commands that deal with transactions
within a database. In Oracle, TCL commands primarily include COMMIT, ROLLBACK, SAVEPOINT, SET TRANSACTION,
and AUTOCOMMIT.

4. Differentiate between DELETE and TRUNCATE in Oracle.
DELETE is a DML command that removes specific rows from a table based on a condition, and it can be rolled
back using a ROLLBACK statement. TRUNCATE is a DDL command that removes all rows from a table and releases
the storage space, and it cannot be rolled back.

5. Explain the COMMIT and ROLLBACK statements in Oracle.
1. COMMIT is a TCL command used to permanently save any changes made during the current transaction. Once a
COMMIT statement is executed, the changes become permanent in the database.

2. ROLLBACK, on the other hand, is a TCL command that reverts any changes made during the current transaction
back to the last COMMIT point  or the beginning of the transaction if no COMMIT has been issued.

6. What is the purpose of the SAVEPOINT statement in Oracle?
SAVEPOINT is a TCL command used to define a point within a transaction to which you can later roll back. It
allows you to partially roll back a transaction instead of rolling back the entire transaction.

7. Explain the CASCADE CONSTRAINTS option in Oracle when dropping a table.
CASCADE CONSTRAINTS is an option used with the DROP TABLE statement in Oracle. When CASCADE CONSTRAINTS is
specified, it will automatically drop all the referential integrity constraints (foreign key constraints)
that refer to the primary or unique key columns of the table being dropped.

8. What is SET TRANSACTION in TCL?
SET TRANSACTION is used to specify properties for a transaction, such as isolation level, access mode, and
transaction name. It allows you to control various aspects of how transactions are processed by the database.

9. What is AUTOCOMMIT in TCL?
AUTOCOMMIT is a mode that can be enabled or disabled in Oracle. When AUTOCOMMIT is enabled, each individual
SQL statement is treated as a separate transaction, and it is automatically committed after execution. When
AUTOCOMMIT is disabled, you need to explicitly issue a COMMIT or ROLLBACK command to end the transaction.

10. Explain the difference between UPDATE and MERGE statements.
Both modify existing data, but UPDATE edits specific rows based on a WHERE clause, while MERGE can perform
INSERT, UPDATE, or DELETE based on a matched condition. MERGE is generally more concise for complex operations.

11. Write a query to create a table named Customers with columns for customer_id (number), customer_name
(varchar2), and city (varchar2)?
CREATE TABLE Customers (
  customer_id NUMBER PRIMARY KEY,
  customer_name VARCHAR2(50) NOT NULL,
  city VARCHAR2(30)
);

12. Describe the concept of constraints in Oracle and their types.
Constraints enforce data integrity within tables. Common types include:
1. PRIMARY KEY: Ensures unique values in a column or set of columns.
2. FOREIGN KEY: Creates a link between two tables, referencing a PRIMARY KEY in another table.
2. NOT NULL: Prevents null values in a column.

13. Explain the concept of ACID properties in transactions.
ACID stands for below,
Atomicity: Transactions are indivisible units of work, either all succeed or all fail.
Consistency: Transactions maintain data integrity by following defined rules.
Isolation: Transactions are isolated from each other, preventing interference.
Durability: Once committed, changes made by a transaction are permanent.

14. What is a subquery?
A subquery is a query nested within another query. It is enclosed within parentheses and can be used in
various parts of a SQL statement, such as the WHERE clause, FROM clause, SELECT clause, or HAVING clause.

15. What are the types of subqueries in Oracle SQL?
1. Single-row subquery: A subquery that returns only one row and one column.
2. Multi-row subquery: A subquery that returns multiple rows but only one column.

16. What is the difference between a correlated and a non-correlated subquery?
1. Non-correlated subquery: A subquery that can be executed independently of the outer query and does not
reference columns from the outer query.
2. Correlated subquery: A subquery that depends on the outer query and references columns from the outer
query.

17. How can you use a subquery in the WHERE clause?
You can use a subquery in the WHERE clause to filter rows based on the result of the subquery.
For example:
SELECT column1 FROM table1 WHERE column2 = (SELECT column3 FROM table2 WHERE condition);

18. What is the result of a subquery that returns NULL values?
If a subquery returns NULL values, it is treated as if it returned an empty set. For example, if a subquery
in the WHERE clause does not match any rows, the outer query will not return any rows.

19. When would you use a subquery instead of a join?
Subqueries are often used when the result set of the inner query is dynamic and depends on the data in the
database or when the query logic is more straightforward to express using a subquery. Joins are typically
used when joining tables based on common columns.

20. What is the EXISTS and IN operators, and how is it used with subqueries?
The EXISTS operator is used to test for the existence of rows returned by a subquery. It returns TRUE if
the subquery returns at least one row; otherwise, it returns FALSE. The EXISTS operator is commonly used
in correlated subqueries.
SELECT column1 FROM table1 WHERE EXISTS (SELECT * FROM table2 WHERE condition);

The IN operator is used to filters rows in the outer query based on whether their values are present in
the subquery result set.
SELECT column1 FROM table1 WHERE IN (SELECT * FROM table2 WHERE condition);

21. Write a query to find all employees who earn more than the average salary in the company.
SELECT * FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);

22. Find the name of the department with the highest number of employees.
SELECT department_name FROM departments WHERE number_of_employees = (SELECT MAX(number_of_employees)
FROM departments);

23. Identify customers who haven't placed any orders in the last 6 months.
SELECT * FROM customers c WHERE NOT EXISTS (SELECT 1 FROM orders o
WHERE o.customer_id = c.customer_id AND order_date > SYSDATE - 180);

24. What is a join in Oracle SQL?
A join is a SQL operation used to combine rows from two or more tables based on a related column
between them.

25. What are the different types of joins in Oracle SQL?
1. Inner Joins (Simple Join)
2. Left Outer Join (Left Join)
3. Right Outer Join (Right Join)
4. Full Outer Join (Full Join)
5. Equijoins
6. Self Joins
7. Cross Joins (Cartesian Products)
8. Antijoins
9. Semijoins

26. What is Inner Join?
Inner Join is the simplest and most common type of join. It is also known as simple join. It returns
all rows from multiple tables where the join condition is met.

Suppliers Table
===============
Supplier Id     Supplier Name           Supplier Address
-------------------------------------------------------
1               Bata Shoes              Agra
2               Walkaro Slippers        Delhi
3               Bombay Dying Shocks     Mumbai

Orders Table
============
order Num       Supplier Id         City
-----------------------------------------
101             1                   Allahabad
102             2                   Kanpur

SELECT columns FROM table1 INNER JOIN table2 ON table1.column = table2.column;

SELECT suppliers.supplier_id, suppliers.supplier_name, orders.order_number
FROM suppliers INNER JOIN orders
ON suppliers.supplier_id = orders.supplier_id;

Output
======
supplier_id   | supplier_name        | order_number
---------------------------------------------------
1             | Bata Shoes           | 101
2             | Walkaro Slippers     | 102

Explanation:
============
Supplier ID 1 ("Bata Shoes") has an order associated with it, which is Order Number 101.
Supplier ID 2 ("Walkaro Slippers") has an order associated with it, which is Order Number 102.
Supplier ID 3 ("Bombay Dying Shocks") does not have any orders associated with it, so it does not appear
in the result set.

27. What is Left Outer Join / Left Join?
Left Outer Join returns all rows from the left (first) table specified in the ON condition and only
those rows from the right (second) table where the join condition is met.

Suppliers Table
===============
Supplier Id     Supplier Name           Supplier Address
-------------------------------------------------------
1               Bata Shoes              Agra
2               Walkaro Slippers        Delhi
3               Bombay Dying Shocks     Mumbai

Orders Table
============
order Num       Supplier Id         City
-----------------------------------------
101             1                   Allahabad
102             2                   Kanpur

SELECT columns  FROM table1 LEFT [OUTER] JOIN table2 ON table1.column = table2.column;

SELECT suppliers.supplier_id, suppliers.supplier_name, orders.order_number
FROM suppliers LEFT [OUTER] JOIN order
ON suppliers.supplier_id = orders.supplier_id;

Output
======
supplier_id   | supplier_name        | order_number
---------------------------------------------------
1             | Bata Shoes           | 101
2             | Walkaro Slippers     | 102
3             | Bombay Dying Shocks  | NULL

Explanation:
============
Supplier ID 1 ("Bata Shoes") has an order associated with it, which is Order Number 101.
Supplier ID 2 ("Walkaro Slippers") has an order associated with it, which is Order Number 102.
Supplier ID 3 ("Bombay Dying Shocks") does not have any orders associated with it, so the order number
column shows NULL for this supplier.

28. What is Right Outer Join / Right Join?
The Right Outer Join returns all rows from the right-hand table specified in the ON condition and only
those rows from the other table where the join condition is met.

Suppliers Table
===============
Supplier Id     Supplier Name           Supplier Address
-------------------------------------------------------
1               Bata Shoes              Agra
2               Walkaro Slippers        Delhi
3               Bombay Dying Shocks     Mumbai

Orders Table
============
order Num       Supplier Id         City
-----------------------------------------
101             1                   Allahabad
102             2                   Kanpur

SELECT columns FROM table1 RIGHT [OUTER] JOIN table2 ON table1.column = table2.column;

SELECT orders.order_number, orders.city, suppliers.supplier_name
FROM suppliers RIGHT OUTER JOIN orders
ON orders.supplier_id = suppliers.supplier_id;

Output
======
order_num   | city       | supplier_name
-----------------------------------------
101         | Allahabad  | Bata Shoes
102         | Kanpur     | Walkaro Slippers

Explanation:
============
Order 101 is associated with Supplier ID 1, which corresponds to "Bata Shoes" in the suppliers table.
Order 102 is associated with Supplier ID 2, which corresponds to "Walkaro Slippers" in the suppliers table.
Since there are no orders associated with Supplier ID 3, the supplier information for Supplier ID 3 ("Bombay
Dying Shocks") will not appear in the output, resulting in NULL values for supplier_name in those rows.

29. What is Full Outer Join / Full Join?
The Full Outer Join returns all rows from the left hand table and right hand table. It places NULL
where the join condition is not met.

Suppliers Table
===============
Supplier Id     Supplier Name           Supplier Address
-------------------------------------------------------
1               Bata Shoes              Agra
2               Walkaro Slippers        Delhi
3               Bombay Dying Shocks     Mumbai

Orders Table
============
order Num       Supplier Id         City
-----------------------------------------
101             1                   Allahabad
102             2                   Kanpur

SELECT columns FROM table1 FULL [OUTER] JOIN table2 ON table1.column = table2.column;

SELECT suppliers.supplier_id, suppliers.supplier_name, orders.order_number
FROM suppliers
FULL OUTER JOIN orders
ON suppliers.supplier_id = orders.supplier_id;

Output
======
supplier_id   | supplier_name        | order_number
---------------------------------------------------
1             | Bata Shoes           | 101
2             | Walkaro Slippers     | 102
3             | Bombay Dying Shocks  | NULL
NULL          | NULL                 | NULL

Explanation:
============
Supplier ID 1 ("Bata Shoes") has an order associated with it, which is Order Number 101.
Supplier ID 2 ("Walkaro Slippers") has an order associated with it, which is Order Number 102.
Supplier ID 3 ("Bombay Dying Shocks") does not have any orders associated with it, so it appears in the
result set with a NULL value for the order number.
The last row with NULL values represents an order that does not have a corresponding supplier. This occurs
because of the FULL OUTER JOIN, which includes all rows from both tables, regardless of whether there is a
match.

30. What is EQUI JOIN in Oracle?
Oracle Equi join returns the matching column values of the associated tables. It uses a comparison operator
in the WHERE clause to refer equality.

Equi join also can be performed by using JOIN keyword followed by ON keyword and then specifying names of the
columns along with their associated tables to check equality.

Agent Table
===========
Agent_Id    Agent_Name    Agent_City
------------------------------------
1           John          Texas
2           Alex          Missouri
3           Erick         New Jersey

Customer Table
==============
Cust_Id     FirstName     LastName
----------------------------------
3           Erick         Samson
4           Richard       Peterson

SELECT column_list FROM table1, table2 WHERE table1.column_name = table2.column_name;
SELECT * FROM table1 JOIN table2 [ON (join_condition)]

SELECT agents.agent_city, customer.LastName, customer.FirstName
FROM Agent, Customer WHERE agents.Agent_Id = customer.Cust_Id;

SELECT agents.agent_city, customer.LastName, customer.FirstName
FROM Agent JOIN Customer ON agents.Agent_Id = customer.Cust_Id;

Output
======
Agent_City    LastName    FirstName
-----------------------------------
New Jersey    Samson      Erick

Explanation:
============
1. The query performs an inner join between the Agent table and the Customer table based on matching Agent_Id
from the Agent table with Cust_Id from the Customer table.
2. Only one row is returned because there's a match between Agent_Id 3 in the Agent table and Cust_Id 3 in the
Customer table.
3. The resulting row includes the Agent_City from the Agent table and the LastName and FirstName from the
Customer table for the matched customer.

31. What is Self Join in Oracle?
A self-join is a join operation where a table is joined with itself. This is useful when you want to compare
rows within the same table or find hierarchical relationships within the table.

Employees Table
===============
Employee_ID  |  Employee_Name  |  Manager_ID
--------------------------------------------
1            |  John           |  3
2            |  Alice          |  1
3            |  Smith          |  NULL
4            |  Emily          |  3
5            |  Bob            |  2

In this table, the Manager_ID column represents the ID of the manager for each employee. The manager of an
employee is also an employee in the same table.

SELECT e.Employee_Name AS Employee, m.Employee_Name AS Manager
FROM Employees e INNER JOIN Employees m ON e.Manager_ID = m.Employee_ID;

SELECT e.Employee_Name AS Employee, m.Employee_Name AS Manager
FROM Employees e, Employees m
WHERE e.Manager_ID = m.Employee_ID;

Output
======
Employee  |  Manager
---------------------
John      |  Smith
Alice     |  John
Smith     |  NULL
Emily     |  Smith
Bob       |  Alice

Explanation
============
We are selecting two columns, aliased as Employee and Manager, which represent the employee's name and their
manager's name, respectively.

We're performing an inner join between the Employees table, aliased as e, and itself, aliased as m.

The ON clause specifies the condition for the join, which is e.Manager_ID = m.Employee_ID. This means that we
are matching each employee's Manager_ID with another employee's Employee_ID, effectively finding the manager
for each employee.

Since it's an inner join, only rows with matching Manager_ID and Employee_ID values will be included in the
result set. This means that employees without managers or managers without employees will not appear in the
result.

Finally, we alias the columns to distinguish between the employee's name (Employee) and the manager's name
(Manager).

32. What is Cross Join in Oracle?
The CROSS JOIN specifies that all rows from first table join with all of the rows of second table. If there
are "x" rows in table1 and "y" rows in table2 then the cross join result set have x*y rows. It normally happens
when no matching join columns are specified.

In simple words you can say that if two tables in a join query have no join condition, then the Oracle returns
their Cartesian product.

SELECT * FROM table1 CROSS JOIN table2;
SELECT * FROM table1, table2;

Customer Table
==============
Cust_Id     FirstName     LastName
----------------------------------
1           Erick         Samson
2           Richard       Peterson

Suppliers Table
===============
Supplier Id     Supplier Name           Supplier Address
-------------------------------------------------------
1               Bata Shoes              Agra
2               Walkaro Slippers        Delhi
3               Bombay Dying Shocks     Mumbai

SELECT * FROM Suppliers CROSS JOIN Customer;

Output
======
Supplier Id  |  Supplier Name         |  Supplier Address     |  Cust_Id  |  FirstName  |  LastName
-----------------------------------------------------------------------------------------------------
1            |  Bata Shoes            |  Agra                 |  1        |  Erick      |  Samson
2            |  Walkaro Slippers      |  Delhi                |  1        |  Erick      |  Samson
3            |  Bombay Dying Shocks   |  Mumbai               |  1        |  Erick      |  Samson
1            |  Bata Shoes            |  Agra                 |  2        |  Richard    |  Peterson
2            |  Walkaro Slippers      |  Delhi                |  2        |  Richard    |  Peterson
3            |  Bombay Dying Shocks   |  Mumbai               |  2        |  Richard    |  Peterson

Explanation:
============
1. Each row from the Suppliers table is combined with every row from the Customer table.
2. The resulting table has all possible combinations of supplier and customer data.
3. For each supplier, there is a row for each customer, resulting in a total of 3 suppliers * 2 customers = 6
rows in the output.

33. What is AntiJoin in Oracle?
Anti-join is used to make the queries run faster. It is a very powerful SQL construct Oracle offers for
faster queries.
Anti-join between two tables returns rows from the first table where no matches are found in the second
table. It is opposite of a semi-join. An anti-join returns one copy of each row in the first table for
which no match is found.
Anti-joins are written using the NOT EXISTS or NOT IN constructs.

Department Table
================
Department_Id       Department_Name
-----------------------------------
1                   HR
2                   Finance
3                   Management

Employee Table
==============
Employee_Id     First_Name      Last_Name       Department_Id
-------------------------------------------------------------
1               John            Smith           1
2               Alex            PeterSon        -
3               Erick           Son             2

SELECT department.department_id, department.department_name
FROM     department
WHERE    NOT EXISTS
(SELECT 1 FROM employee WHERE employee.department_id = department.department_id)
ORDER BY department.department_id;

Output
======
Department_Id | Department_Name
--------------------------------
3             | Management

Explanation:
============
1. SELECT department.Department_Id, department.Department_Name: This part of the query selects the
Department_Id and Department_Name columns from the Department table.
2. FROM Department: We specify the Department table as the source of data.
3. WHERE NOT EXISTS: This clause is used to filter out departments for which the subquery does not
return any rows.
4. SELECT 1 FROM Employee WHERE Employee.Department_Id = Department.Department_Id: This is a subquery
that checks if there are any rows in the Employee table where the Department_Id matches the
Department_Id of the outer query. If no such rows exist, the NOT EXISTS condition evaluates to true
for that department.
5. ORDER BY department.Department_Id: This orders the result set by the Department_Id in ascending
order.

34. What is Semi Join in Oracle?
Semi-join is introduced in Oracle 8.0. It provides an efficient method of performing a WHERE EXISTS
sub-query.
A semi-join returns one copy of each row in first table for which at least one match is found.
Semi-joins are written using the EXISTS construct.

Department Table
================
Department_Id       Department_Name
-----------------------------------
1                   HR
2                   Finance
3                   Management

Employee Table
==============
Employee_Id     First_Name      Last_Name       Department_Id
-------------------------------------------------------------
1               John            Smith           1
2               Alex            PeterSon        -
3               Erick           Son             2

SELECT department.department_id, department.department_name
FROM     department
WHERE    EXISTS
(SELECT 1 FROM employee WHERE employee.department_id = department.department_id)
ORDER BY department.department_id;

Output
======
Department_Id   Department_Name
--------------------------------
1               HR
2               Finance

Explanation
===========
1. The Department table has three departments: HR, Finance, and Management.
2. The Employee table has two records with valid Department_Id values (1 and 2).
3. The query retrieves departments from the Department table where there is at least one corresponding
record in the Employee table.
4. Departments with Department_Id 1 (HR) and 2 (Finance) have employees associated with them, so they
satisfy the condition and are returned as the output. The department with Department_Id 3 (Management)
does not have any employees associated with it, so it is excluded from the result.

34. What is the difference between INNER JOIN and OUTER JOIN?
1. INNER JOIN returns only the rows where there is a match in both tables.
2. OUTER JOIN returns all rows from one or both tables, depending on the type of outer join, and includes
unmatched rows with NULL values.

35. What is a self-join, and how is it used?
A self-join is a join in which a table is joined with itself. It is often used to compare rows within
the same table or to find hierarchical relationships within the table.

36. What is the difference between a join condition specified in the WHERE clause and the ON clause?
1. The join condition specified in the WHERE clause is used for implicit joins, where tables are listed with
commas in the FROM clause.
2. The ON clause is used for explicit joins (ANSI SQL syntax) and specifies the join condition directly after
the JOIN keyword.

